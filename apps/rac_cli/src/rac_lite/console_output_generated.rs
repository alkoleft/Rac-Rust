// @generated by scripts/rac/console_output_codegen.py. DO NOT EDIT.
// source: /home/alko/develop/open-source/v8_protocols/schemas/rac/console_output.toml

pub struct InfobaseSummaryInfoDisplay<'a> {
    item: &'a InfobaseSummary,
}

pub fn infobase_summary_info(item: &InfobaseSummary) -> InfobaseSummaryInfoDisplay<'_> {
    InfobaseSummaryInfoDisplay { item }
}

fn render_infobase_summary_info(out: &mut String, item: &InfobaseSummary) {
    outln!(out, "infobase: {}", format_uuid(&item.infobase));
    outln!(out, "name: {}", display_str(&item.name));
    outln!(out, "descr: \"{}\"", item.descr);
}

impl Display for InfobaseSummaryInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_infobase_summary_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct InfobaseSummaryListDisplay<'a> {
    items: &'a [InfobaseSummary],
}

pub fn infobase_summary_list(items: &[InfobaseSummary]) -> InfobaseSummaryListDisplay<'_> {
    InfobaseSummaryListDisplay { items }
}

impl Display for InfobaseSummaryListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("infobases", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_infobase_summary_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ConnectionInfoDisplay<'a> {
    item: &'a ConnectionRecord,
}

pub fn connection_info(item: &ConnectionRecord) -> ConnectionInfoDisplay<'_> {
    ConnectionInfoDisplay { item }
}

fn render_connection_info(out: &mut String, item: &ConnectionRecord) {
    outln!(out, "connection: {}", format_uuid(&item.connection));
    outln!(out, "application: {}", display_str(&item.application));
    outln!(out, "connected-at: {}", display_str(&item.connected_at));
    outln!(out, "conn-id: {}", item.conn_id);
    outln!(out, "host: {}", display_str(&item.host));
    outln!(out, "infobase: {}", format_uuid(&item.infobase));
    outln!(out, "process: {}", format_uuid(&item.process));
    outln!(out, "session-number: {}", item.session_number);
    outln!(out, "blocked-by-ls: {}", item.blocked_by_ls);
}

impl Display for ConnectionInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_connection_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ConnectionListDisplay<'a> {
    items: &'a [ConnectionRecord],
}

pub fn connection_list(items: &[ConnectionRecord]) -> ConnectionListDisplay<'_> {
    ConnectionListDisplay { items }
}

impl Display for ConnectionListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("connections", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_connection_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ManagerInfoDisplay<'a> {
    item: &'a ManagerRecord,
}

pub fn manager_info(item: &ManagerRecord) -> ManagerInfoDisplay<'_> {
    ManagerInfoDisplay { item }
}

fn render_manager_info(out: &mut String, item: &ManagerRecord) {
    outln!(out, "manager: {}", format_uuid(&item.manager));
    outln!(out, "pid: {}", display_str(&item.pid));
    outln!(out, "using: {}", manager_using_label(item.using));
    outln!(out, "host: {}", display_str(&item.host));
    outln!(out, "port: {}", item.port);
    outln!(out, "descr: \"{}\"", display_str(&item.descr));
}

impl Display for ManagerInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_manager_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ManagerListDisplay<'a> {
    items: &'a [ManagerRecord],
}

pub fn manager_list(items: &[ManagerRecord]) -> ManagerListDisplay<'_> {
    ManagerListDisplay { items }
}

impl Display for ManagerListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("managers", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_manager_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ServerInfoDisplay<'a> {
    item: &'a ServerRecord,
}

pub fn server_info(item: &ServerRecord) -> ServerInfoDisplay<'_> {
    ServerInfoDisplay { item }
}

fn render_server_info(out: &mut String, item: &ServerRecord) {
    outln!(out, "server: {}", format_uuid(&item.server));
    outln!(out, "agent-host: {}", display_str(&item.agent_host));
    outln!(out, "agent-port: {}", item.agent_port);
    outln!(out, "name: \"{}\"", display_str(&item.name));
    outln!(out, "using: {}", server_using_label(item.using));
    outln!(out, "dedicate-managers: {}", dedicate_managers_label(item.dedicate_managers));
    outln!(out, "infobases-limit: {}", item.infobases_limit);
    outln!(out, "safe-call-memory-limit: {}", item.safe_call_memory_limit);
    outln!(out, "connections-limit: {}", item.connections_limit);
    outln!(out, "cluster-port: {}", item.cluster_port);
    outln!(out, "port-range: {}:{}", item.port_range_start, item.port_range_end);
    outln!(out, "critical-total-memory: {}", item.critical_total_memory);
    outln!(out, "temporary-allowed-total-memory: {}", item.temporary_allowed_total_memory);
    outln!(out, "temporary-allowed-total-memory-time-limit: {}", item.temporary_allowed_total_memory_time_limit);
    outln!(out, "service-principal-name: \"{}\"", display_str(&item.service_principal_name));
    outln!(out, "restart-schedule: \"{}\"", display_str(&item.restart_schedule));
}

impl Display for ServerInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_server_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ServerListDisplay<'a> {
    items: &'a [ServerRecord],
}

pub fn server_list(items: &[ServerRecord]) -> ServerListDisplay<'_> {
    ServerListDisplay { items }
}

impl Display for ServerListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("servers", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_server_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ProcessInfoDisplay<'a> {
    item: &'a ProcessRecord,
}

pub fn process_info(item: &ProcessRecord) -> ProcessInfoDisplay<'_> {
    ProcessInfoDisplay { item }
}

fn render_process_info(out: &mut String, item: &ProcessRecord) {
    outln!(out, "process: {}", format_uuid(&item.process));
    outln!(out, "host: {}", display_str(&item.host));
    outln!(out, "port: {}", item.port);
    outln!(out, "pid: {}", display_str(&item.pid));
    outln!(out, "turned-on: {}", yes_no(item.turned_on));
    outln!(out, "running: {}", yes_no(item.running));
    outln!(out, "started-at: {}", display_str(&item.started_at));
    outln!(out, "use: {}", process_use_label(item.use_status));
    outln!(out, "available-performance: {}", item.available_performance);
    outln!(out, "capacity: {}", item.capacity);
    outln!(out, "connections: {}", item.connections);
    outln!(out, "memory-size: {}", item.memory_size);
    outln!(out, "memory-excess-time: {}", item.memory_excess_time);
    outln!(out, "selection-size: {}", item.selection_size);
    outln!(out, "avg-call-time: {:.3}", item.avg_call_time);
    outln!(out, "avg-db-call-time: {:.3}", item.avg_db_call_time);
    outln!(out, "avg-lock-call-time: {:.3}", item.avg_lock_call_time);
    outln!(out, "avg-server-call-time: {:.3}", item.avg_server_call_time);
    outln!(out, "avg-threads: {:.3}", item.avg_threads);
    outln!(out, "reserve: {}", yes_no(item.reserve));
}

impl Display for ProcessInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_process_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ProcessListDisplay<'a> {
    items: &'a [ProcessRecord],
}

pub fn process_list(items: &[ProcessRecord]) -> ProcessListDisplay<'_> {
    ProcessListDisplay { items }
}

impl Display for ProcessListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("processes", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_process_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct LockInfoDisplay<'a> {
    item: &'a LockRecordRaw,
}

pub fn lock_info(item: &LockRecordRaw) -> LockInfoDisplay<'_> {
    LockInfoDisplay { item }
}

fn render_lock_info(out: &mut String, item: &LockRecordRaw) {
    outln!(out, "connection: {}", format_uuid(&item.connection));
    outln!(out, "descr: {}", display_str(&item.descr.descr));
    if let Some(flag) = item.descr.descr_flag {
        outln!(out, "descr-flag: {}", flag);
    }
    outln!(out, "locked-at: {}", display_str(&item.locked_at));
    outln!(out, "session: {}", format_uuid(&item.session));
    outln!(out, "object: {}", format_uuid(&item.object));
}

impl Display for LockInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_lock_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct LockListDisplay<'a> {
    items: &'a [LockRecordRaw],
}

pub fn lock_list(items: &[LockRecordRaw]) -> LockListDisplay<'_> {
    LockListDisplay { items }
}

impl Display for LockListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("locks", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_lock_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct RuleInfoDisplay<'a> {
    item: &'a RuleRecord,
}

pub fn rule_info(item: &RuleRecord) -> RuleInfoDisplay<'_> {
    RuleInfoDisplay { item }
}

fn render_rule_info(out: &mut String, item: &RuleRecord) {
    outln!(out, "rule: {}", format_uuid(&item.rule));
    outln!(out, "object-type: {}", item.object_type);
    outln!(out, "infobase-name: {}", display_str(&item.infobase_name));
    outln!(out, "rule-type: {}", rule_type_label(item.rule_type));
    outln!(out, "application-ext: {}", display_str(&item.application_ext));
    outln!(out, "priority: {}", item.priority);
}

impl Display for RuleInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_rule_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct RuleListDisplay<'a> {
    items: &'a [RuleRecord],
}

pub fn rule_list(items: &[RuleRecord]) -> RuleListDisplay<'_> {
    RuleListDisplay { items }
}

impl Display for RuleListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("rules", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_rule_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct LimitInfoDisplay<'a> {
    item: &'a LimitRecord,
}

pub fn limit_info(item: &LimitRecord) -> LimitInfoDisplay<'_> {
    LimitInfoDisplay { item }
}

fn render_limit_info(out: &mut String, item: &LimitRecord) {
    outln!(out, "limit: {}", display_str(&item.name));
    outln!(out, "counter: {}", display_str(&item.counter));
    outln!(out, "action: {}", item.action);
    outln!(out, "duration: {}", item.duration);
    outln!(out, "cpu-time: {}", item.cpu_time);
    outln!(out, "memory: {}", item.memory);
    outln!(out, "read: {}", item.read);
    outln!(out, "write: {}", item.write);
    outln!(out, "duration-dbms: {}", item.duration_dbms);
    outln!(out, "dbms-bytes: {}", item.dbms_bytes);
    outln!(out, "service: {}", item.service);
    outln!(out, "call: {}", item.call);
    outln!(out, "number-of-active-sessions: {}", item.number_of_active_sessions);
    outln!(out, "number-of-sessions: {}", item.number_of_sessions);
    outln!(out, "error-message: {}", display_str(&item.error_message));
    outln!(out, "descr: {}", display_str(&item.descr));
}

impl Display for LimitInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_limit_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct LimitListDisplay<'a> {
    items: &'a [LimitRecord],
}

pub fn limit_list(items: &[LimitRecord]) -> LimitListDisplay<'_> {
    LimitListDisplay { items }
}

impl Display for LimitListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("limits", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_limit_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ServiceSettingInfoDisplay<'a> {
    item: &'a ServiceSettingRecord,
}

pub fn service_setting_info(item: &ServiceSettingRecord) -> ServiceSettingInfoDisplay<'_> {
    ServiceSettingInfoDisplay { item }
}

fn render_service_setting_info(out: &mut String, item: &ServiceSettingRecord) {
    outln!(out, "setting: {}", format_uuid(&item.setting));
    outln!(out, "service-name: {}", display_str(&item.service_name));
    outln!(out, "infobase-name: {}", display_str(&item.infobase_name));
    outln!(out, "service-data-dir: {}", display_str(&item.service_data_dir));
    outln!(out, "active: {}", yes_no(item.active));
}

impl Display for ServiceSettingInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_service_setting_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ServiceSettingListDisplay<'a> {
    items: &'a [ServiceSettingRecord],
}

pub fn service_setting_list(items: &[ServiceSettingRecord]) -> ServiceSettingListDisplay<'_> {
    ServiceSettingListDisplay { items }
}

impl Display for ServiceSettingListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("service-settings", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_service_setting_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ServiceSettingTransferDataDirInfoDisplay<'a> {
    item: &'a ServiceSettingTransferDataDirRecord,
}

pub fn service_setting_transfer_data_dir_info(item: &ServiceSettingTransferDataDirRecord) -> ServiceSettingTransferDataDirInfoDisplay<'_> {
    ServiceSettingTransferDataDirInfoDisplay { item }
}

fn render_service_setting_transfer_data_dir_info(out: &mut String, item: &ServiceSettingTransferDataDirRecord) {
    outln!(out, "service-name: {}", display_str(&item.service_name));
    outln!(out, "user: {}", display_str(&item.user));
    outln!(out, "source-dir: {}", display_str(&item.source_dir));
    outln!(out, "target-dir: {}", display_str(&item.target_dir));
}

impl Display for ServiceSettingTransferDataDirInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_service_setting_transfer_data_dir_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ServiceSettingTransferDataDirsDisplay<'a> {
    items: &'a [ServiceSettingTransferDataDirRecord],
}

pub fn service_setting_get_data_dirs_for_transfer(items: &[ServiceSettingTransferDataDirRecord]) -> ServiceSettingTransferDataDirsDisplay<'_> {
    ServiceSettingTransferDataDirsDisplay { items }
}

impl Display for ServiceSettingTransferDataDirsDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("service-data-dirs", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_service_setting_transfer_data_dir_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct CounterInfoDisplay<'a> {
    item: &'a CounterRecord,
}

pub fn counter_info(item: &CounterRecord) -> CounterInfoDisplay<'_> {
    CounterInfoDisplay { item }
}

fn render_counter_info(out: &mut String, item: &CounterRecord) {
    outln!(out, "name: {}", display_str(&item.name));
    outln!(out, "collection-time: {}", item.collection_time);
    outln!(out, "group: {}", item.group);
    outln!(out, "filter-type: {}", item.filter_type);
    outln!(out, "filter: {}", display_str(&item.filter));
    outln!(out, "duration: {}", item.duration);
    outln!(out, "cpu-time: {}", item.cpu_time);
    outln!(out, "duration-dbms: {}", item.duration_dbms);
    outln!(out, "service: {}", item.service);
    outln!(out, "memory: {}", item.memory);
    outln!(out, "read: {}", item.read);
    outln!(out, "write: {}", item.write);
    outln!(out, "dbms-bytes: {}", item.dbms_bytes);
    outln!(out, "call: {}", item.call);
    outln!(out, "number-of-active-sessions: {}", item.number_of_active_sessions);
    outln!(out, "number-of-sessions: {}", item.number_of_sessions);
    outln!(out, "descr: {}", display_str(&item.descr));
}

impl Display for CounterInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_counter_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct CounterListDisplay<'a> {
    items: &'a [CounterRecord],
}

pub fn counter_list(items: &[CounterRecord]) -> CounterListDisplay<'_> {
    CounterListDisplay { items }
}

impl Display for CounterListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("counters", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_counter_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct CounterValuesInfoDisplay<'a> {
    item: &'a CounterValuesRecord,
}

pub fn counter_values_info(item: &CounterValuesRecord) -> CounterValuesInfoDisplay<'_> {
    CounterValuesInfoDisplay { item }
}

fn render_counter_values_info(out: &mut String, item: &CounterValuesRecord) {
    outln!(out, "object: {}", display_str(&item.object));
    outln!(out, "collection-time: {}", item.collection_time);
    outln!(out, "duration: {}", item.duration);
    outln!(out, "cpu-time: {}", item.cpu_time);
    outln!(out, "memory: {}", item.memory);
    outln!(out, "read: {}", item.read);
    outln!(out, "write: {}", item.write);
    outln!(out, "duration-dbms: {}", item.duration_dbms);
    outln!(out, "dbms-bytes: {}", item.dbms_bytes);
    outln!(out, "service: {}", item.service);
    outln!(out, "call: {}", item.call);
    outln!(out, "number-of-active-sessions: {}", item.number_of_active_sessions);
    outln!(out, "number-of-sessions: {}", item.number_of_sessions);
    outln!(out, "time: {}", display_str(&item.time));
}

impl Display for CounterValuesInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_counter_values_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct CounterValuesDisplay<'a> {
    items: &'a [CounterValuesRecord],
}

pub fn counter_values(items: &[CounterValuesRecord]) -> CounterValuesDisplay<'_> {
    CounterValuesDisplay { items }
}

impl Display for CounterValuesDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("counter-values", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_counter_values_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct CounterAccumulatedValuesDisplay<'a> {
    items: &'a [CounterValuesRecord],
}

pub fn counter_accumulated_values(items: &[CounterValuesRecord]) -> CounterAccumulatedValuesDisplay<'_> {
    CounterAccumulatedValuesDisplay { items }
}

impl Display for CounterAccumulatedValuesDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("counter-accumulated-values", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_counter_values_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct AgentAdminInfoDisplay<'a> {
    item: &'a AgentAdminRecord,
}

pub fn agent_admin_info(item: &AgentAdminRecord) -> AgentAdminInfoDisplay<'_> {
    AgentAdminInfoDisplay { item }
}

fn render_agent_admin_info(out: &mut String, item: &AgentAdminRecord) {
    outln!(out, "name: {}", display_str(&item.name));
    outln!(out, "unknown-tag: {}", item.unknown_tag);
    outln!(out, "unknown-flags: 0x{:08x}", item.unknown_flags);
    outln!(out, "unknown-tail: {:02x} {:02x} {:02x}", item.unknown_tail[0], item.unknown_tail[1], item.unknown_tail[2]);
}

impl Display for AgentAdminInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_agent_admin_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct AgentAdminListDisplay<'a> {
    items: &'a [AgentAdminRecord],
}

pub fn agent_admin_list(items: &[AgentAdminRecord]) -> AgentAdminListDisplay<'_> {
    AgentAdminListDisplay { items }
}

impl Display for AgentAdminListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("agent-admins", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_agent_admin_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ClusterAdminInfoDisplay<'a> {
    item: &'a ClusterAdminRecord,
}

pub fn cluster_admin_info(item: &ClusterAdminRecord) -> ClusterAdminInfoDisplay<'_> {
    ClusterAdminInfoDisplay { item }
}

fn render_cluster_admin_info(out: &mut String, item: &ClusterAdminRecord) {
    outln!(out, "name: {}", display_str(&item.name));
    outln!(out, "unknown-tag: {}", item.unknown_tag);
    outln!(out, "unknown-flags: 0x{:08x}", item.unknown_flags);
    outln!(out, "unknown-tail: {:02x} {:02x} {:02x}", item.unknown_tail[0], item.unknown_tail[1], item.unknown_tail[2]);
}

impl Display for ClusterAdminInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_cluster_admin_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ClusterAdminListDisplay<'a> {
    items: &'a [ClusterAdminRecord],
}

pub fn cluster_admin_list(items: &[ClusterAdminRecord]) -> ClusterAdminListDisplay<'_> {
    ClusterAdminListDisplay { items }
}

impl Display for ClusterAdminListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("cluster-admins", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_cluster_admin_info(out, item);
        });
        write_trimmed(f, &out)
    }
}

pub struct ClusterInfoDisplay<'a> {
    item: &'a ClusterRecord,
}

pub fn cluster_info(item: &ClusterRecord) -> ClusterInfoDisplay<'_> {
    ClusterInfoDisplay { item }
}

fn render_cluster_info(out: &mut String, item: &ClusterRecord) {
    outln!(out, "cluster                                  : {}", format_uuid(&item.uuid));
    outln!(out, "host                                     : {}", display_str(&item.host));
    outln!(out, "port                                     : {}", item.port);
    outln!(out, "name                                     : \"{}\"", display_str(&item.display_name));
    outln!(out, "expiration-timeout                       : {}", item.expiration_timeout);
    outln!(out, "lifetime-limit                           : {}", item.lifetime_limit);
    outln!(out, "max-memory-size                          : {}", item.max_memory_size);
    outln!(out, "max-memory-time-limit                    : {}", item.max_memory_time_limit);
    outln!(out, "security-level                           : {}", item.security_level);
    outln!(out, "session-fault-tolerance-level            : {}", item.session_fault_tolerance_level);
    outln!(out, "load-balancing-mode                      : {}", load_balancing_mode_name(item.load_balancing_mode));
    outln!(out, "errors-count-threshold                   : {}", item.errors_count_threshold);
    outln!(out, "kill-problem-processes                   : {}", item.kill_problem_processes);
    outln!(out, "kill-by-memory-with-dump                 : {}", item.kill_by_memory_with_dump);
    if let Some(value) = item.allow_access_right_audit_events_recording {
        outln!(out, "allow-access-right-audit-events-recording: {}", value);
    }
    if let Some(value) = item.ping_period {
        outln!(out, "ping-period                              : {}", value);
    }
    if let Some(value) = item.ping_timeout {
        outln!(out, "ping-timeout                             : {}", value);
    }
    if let Some(value) = item.restart_schedule_cron.as_ref() {
        outln!(out, "restart-schedule                         : \"{}\"", display_str(value));
    }
}

impl Display for ClusterInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_cluster_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct ClusterListDisplay<'a> {
    items: &'a [ClusterRecord],
}

pub fn cluster_list(items: &[ClusterRecord]) -> ClusterListDisplay<'_> {
    ClusterListDisplay { items }
}

impl Display for ClusterListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        for (idx, item) in self.items.iter().enumerate() {
            if idx > 0 {
                out.push('\n');
            }
            render_cluster_info(&mut out, item);
        }
        write_trimmed(f, &out)
    }
}

pub struct AgentVersionDisplay<'a> {
    item: &'a str,
}

pub fn agent_version(item: &str) -> AgentVersionDisplay<'_> {
    AgentVersionDisplay { item }
}

fn render_agent_version_info(out: &mut String, item: &str) {
    outln!(out, "version: {}", item);
}

impl Display for AgentVersionDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_agent_version_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct SessionInfoDisplay<'a> {
    item: &'a SessionRecord,
}

pub fn session_info(item: &SessionRecord) -> SessionInfoDisplay<'_> {
    SessionInfoDisplay { item }
}

fn render_session_info(out: &mut String, item: &SessionRecord) {
    outln!(out, "session: {}", format_uuid(&item.session));
    outln!(out, "app-id: {}", display_str(&item.app_id));
    outln!(out, "connection: {}", format_uuid(&item.connection));
    outln!(out, "infobase: {}", format_uuid(&item.infobase));
    outln!(out, "process: {}", format_uuid(&item.process));
    outln!(out, "host: {}", display_str(&item.host));
    outln!(out, "hibernate: {}", yes_no(item.hibernate));
    outln!(out, "locale: {}", display_str(&item.locale));
    outln!(out, "user-name: {}", display_str(&item.user_name));
    outln!(out, "started-at: {}", display_str(&item.started_at));
    outln!(out, "last-active-at: {}", display_str(&item.last_active_at));
    outln!(out, "client-ip: {}", display_str(&item.client_ip));
    outln!(out, "db-proc-info: {}", display_str(&item.db_proc_info));
    outln!(out, "db-proc-took-at: {}", display_str(&item.db_proc_took_at));
    outln!(out, "current-service-name: {}", display_str(&item.current_service_name));
    outln!(out, "data-separation: {}", display_str(&item.data_separation));
    append_license_prefixed(out, &item.license, "license.");
    outln!(out, "session-id: {}", item.session_id);
    append_counters_prefixed(out, item, "");
}

impl Display for SessionInfoDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut out = String::new();
        render_session_info(&mut out, self.item);
        write_trimmed(f, &out)
    }
}

pub struct SessionListDisplay<'a> {
    items: &'a [SessionRecord],
}

pub fn session_list(items: &[SessionRecord]) -> SessionListDisplay<'_> {
    SessionListDisplay { items }
}

impl Display for SessionListDisplay<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let out = list_to_string("sessions", self.items, 5, MoreLabel::Default, |out, _idx, item| {
            render_session_info(out, item);
        });
        write_trimmed(f, &out)
    }
}
